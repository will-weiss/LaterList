0 info it worked if it ends with ok
1 verbose cli [ 'node', '/usr/local/bin/npm', 'publish' ]
2 info using npm@2.4.1
3 info using node@v0.10.33
4 verbose node symlink /usr/local/bin/node
5 verbose publish [ '.' ]
6 silly cache add args [ '.', null ]
7 verbose cache add spec .
8 silly cache add parsed spec { raw: '.',
8 silly cache add   scope: null,
8 silly cache add   name: null,
8 silly cache add   rawSpec: '.',
8 silly cache add   spec: '/Users/willweiss/dev/LaterList',
8 silly cache add   type: 'directory' }
9 verbose addLocalDirectory /Users/willweiss/.npm/laterlist/1.0.0/package.tgz not in flight; packing
10 verbose tar pack [ '/Users/willweiss/.npm/laterlist/1.0.0/package.tgz',
10 verbose tar pack   '/Users/willweiss/dev/LaterList' ]
11 verbose tarball /Users/willweiss/.npm/laterlist/1.0.0/package.tgz
12 verbose folder /Users/willweiss/dev/LaterList
13 info prepublish laterlist@1.0.0
14 verbose unsafe-perm in lifecycle true
15 verbose addLocalTarball adding from inside cache /Users/willweiss/.npm/laterlist/1.0.0/package.tgz
16 silly cache afterAdd laterlist@1.0.0
17 verbose afterAdd /Users/willweiss/.npm/laterlist/1.0.0/package/package.json not in flight; writing
18 verbose afterAdd /Users/willweiss/.npm/laterlist/1.0.0/package/package.json written
19 silly publish { name: 'laterlist',
19 silly publish   version: '1.0.0',
19 silly publish   description: 'LaterList: Eventual Arrays with a Familiar API',
19 silly publish   main: 'lib/index.js',
19 silly publish   directories: { test: 'test' },
19 silly publish   scripts:
19 silly publish    { test: 'istanbul cover _mocha -- -R spec --recursive test',
19 silly publish      prepublish: 'gulp' },
19 silly publish   repository: { type: 'git', url: 'https://github.com/will-weiss/LaterList' },
19 silly publish   keywords: [ 'later', 'list', 'array', 'async', 'stream', 'relay', 'flood' ],
19 silly publish   author: { name: 'Will Weiss', email: 'william.t.weiss@gmail.com' },
19 silly publish   license: 'MIT',
19 silly publish   bugs: { url: 'https://github.com/will-weiss/LaterList/issues' },
19 silly publish   homepage: 'https://github.com/will-weiss/LaterList',
19 silly publish   devDependencies:
19 silly publish    { bluebird: '2.9.32',
19 silly publish      browserify: '9.0.3',
19 silly publish      chai: '2.0.0',
19 silly publish      'chai-as-promised': '4.2.0',
19 silly publish      gulp: '^3.9.0',
19 silly publish      'gulp-concat': '^2.6.0',
19 silly publish      'gulp-istanbul': '0.6.0',
19 silly publish      'gulp-jsdoc-to-markdown': '^1.1.1',
19 silly publish      'gulp-mocha': '2.0.0',
19 silly publish      'gulp-rename': '^1.2.2',
19 silly publish      'gulp-uglify': '1.1.0',
19 silly publish      'gulp-util': '^3.0.6',
19 silly publish      istanbul: '0.3.8',
19 silly publish      'jsdoc-to-markdown': '^1.1.1',
19 silly publish      'merge-stream': '^0.1.8',
19 silly publish      mocha: '2.1.0',
19 silly publish      sinon: '1.15.4',
19 silly publish      'sinon-as-promised': '^4.0.0',
19 silly publish      'sinon-chai': '2.8.0',
19 silly publish      'vinyl-transform': '1.0.0' },
19 silly publish   readme: '# LaterList [![Build Status](https://travis-ci.org/will-weiss/LaterList.svg?branch=master)](https://travis-ci.org/will-weiss/LaterList)\n\nHandle asynchronous events as an array that will arrive eventually: a LaterList.\n\n# Install\n\nAvailable via [npm](https://www.npmjs.org/)\n\n```bash\nnpm install laterlist\n```\n\n# Usage\n```javascript\nvar Flood = require(\'LaterList\').Flood;\n\n// Works like an array\nFlood.of(1,2,3,4,5)\n  .map(function(n) {\n    return n + 2;\n  }).filter(function(n) {\n    return n % 2 === 0;\n  }).reduce(function(total, n) {\n    return total + n;\n  }, 0).then(console.log); // 10\n\n// even when callbacks resolve asynchronously\nFlood.from(someUserIds)\n  .map(db.getUserByIdAsync)\n  .reduce(function(pageViews, user) {\n    return pageViews + user.pageViews;\n  }, 0).then(console.log); // Sum total of page views of those users.\n```\n\n# Source\n\n[https://github.com/will-weiss/LaterList](https://github.com/will-weiss/LaterList)\n\n# License\n\nReleased under the MIT License.\n\n#\n\n<a name="LaterList"></a>\n## LaterList\nA LaterList is a linked list which may be used to process values that arrive or\nare processed asynchronously. As in many implementations of streams, listeners\nmay be added to instances of LaterList to process incoming values. There are\nhowever some differences that make LaterList useful.\n\n<ul>\n\n  <li>  Familiar API: Array methods are implemented with an identical syntax.\n        Methods that return or mutate arrays return LaterLists. Other methods\n        wrap their return values in a Promise.\n  </li>\n  <li>  Preservation: Listeners will process a whole list even if they are\n        added after values have been pushed onto the list. Data is never\n        dropped.\n  </li>\n  </li>\n  <li>  Indexing: Values are indexed by the order in which they are pushed.\n  </li>\n  <li>   Fully Asynchronous: A LaterList may be mapped, reduced, filtered,\n         etc. using functions that return Promises. LaterLists process the\n         resolved values of Promises pushed onto them.\n  </li>\n  <li>   Easy Chaining: Methods of LaterLists may be chained together. Values\n         are passed along the chain even before the original list has ended\n         and uncaught exceptions propogate down the chain.\n  </li>\n  <li>   Flexible: The two types of LaterLists - Flood and Relay - share an\n         identical API but differ slightly in when their elements are\n         processed. Elements of a Flood are processed as soon as they are\n         available. Elements of a Relay are processed when processing of all\n         prior elements is done. So, Floods have higher throughput while\n         Relays preserve order, making each suitable for different contexts.\n  </li>\n  <li>   Unbounded: LaterLists may be pushed onto indefinitely without memory\n         overload. When a LaterList is closed, adding new listeners is\n         disabled so that elements processed by existing listeners may be\n         garbage collected.\n  </li>\n  <li>   Active Listeners: Listeners of a LaterList are not simply callbacks;\n         they are their own class and maintain state. As listeners keep a\n         reference to their unprocessed elements, values may be pushed onto a\n         LaterList more quickly than they are processed without needing to\n         worry about backpressure for all but the most memory-intensive\n         applications.\n  </li>\n  <li>   Lightweight: LaterList has a minimal codebase and no dependencies\n         relying only on a JS environment that supports the Promise/A+\n         specification.\n  </li>\n</ul>\n\n## Classes\n<dl>\n<dt><a href="#LaterList/Flood">LaterList/Flood</a> ⇐ <code><a href="#LaterList">LaterList</a></code></dt>\n<dd><p>A Flood is a LaterList for which values are processed immediately.</p>\n</dd>\n<dt><a href="#LaterList/Relay">LaterList/Relay</a> ⇐ <code><a href="#LaterList">LaterList</a></code></dt>\n<dd><p>A Relay is a LaterList for which order is preserved when listened\nto.</p>\n</dd>\n<dt><a href="#LaterList">LaterList</a></dt>\n<dd><p>A LaterList is a linked list which may be used to process values\nthat arrive or are processed asynchronously.</p>\n</dd>\n</dl>\n<a name="LaterList/Flood"></a>\n## LaterList/Flood ⇐ <code>[LaterList](#LaterList)</code>\nA Flood is a LaterList for which values are processed immediately.\n\n**Kind**: global class  \n**Extends:** <code>[LaterList](#LaterList)</code>  \n\n* [LaterList/Flood](#LaterList/Flood) ⇐ <code>[LaterList](#LaterList)</code>\n  * [.length](#LaterList+length) : <code>Number</code>\n  * [.addListener(onData, onEnd, initialValue)](#LaterList/Flood+addListener)\n  * [.push(...values)](#LaterList+push) ⇒ <code>Number</code>\n  * [.revive(fn, err)](#LaterList+revive)\n  * [.end(err)](#LaterList+end)\n  * [.link(onData)](#LaterList+link) ⇒\n  * [.close()](#LaterList+close)\n  * [.consume(onData, initialValue)](#LaterList+consume) ⇒ <code>Promise.&lt;\\*&gt;</code>\n  * [.value()](#LaterList+value) ⇒ <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code>\n  * [.atIndex(index)](#LaterList+atIndex) ⇒ <code>\\*</code>\n  * [.when()](#LaterList+when) ⇒ <code>Promise</code>\n  * [.concat(...lists)](#LaterList+concat) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.every(predicate, thisArg)](#LaterList+every) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n  * [.filter(predicate, thisArg)](#LaterList+filter) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.find(predicate, thisArg)](#LaterList+find) ⇒ <code>Promise.&lt;\\*&gt;</code>\n  * [.findIndex(predicate, thisArg)](#LaterList+findIndex) ⇒ <code>Promise.&lt;Number&gt;</code>\n  * [.forEach(lambda, thisArg)](#LaterList+forEach) ⇒ <code>Promise.&lt;undefined&gt;</code>\n  * [.includes(toMatch, fromIndex)](#LaterList+includes) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n  * [.indexOf(toMatch)](#LaterList+indexOf) ⇒ <code>Promise.&lt;Number&gt;</code>\n  * [.join(separator)](#LaterList+join) ⇒ <code>Promise.&lt;String&gt;</code>\n  * [.lastIndexOf(toMatch)](#LaterList+lastIndexOf) ⇒ <code>Promise.&lt;Number&gt;</code>\n  * [.map(lambda, thisArg)](#LaterList+map) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.reduce(lambda, initialValue)](#LaterList+reduce) ⇒ <code>Promise.&lt;\\*&gt;</code>\n  * [.reduceRight(lambda, initialValue)](#LaterList+reduceRight) ⇒ <code>Promise.&lt;\\*&gt;</code>\n  * [.reverse()](#LaterList+reverse) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.slice(begin, end)](#LaterList+slice) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.some(predicate, thisArg)](#LaterList+some) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n  * [.sort(compare)](#LaterList+sort) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.splice(begin, deleteCount, ...additions)](#LaterList+splice) ⇒ <code>[LaterList](#LaterList)</code>\n\n<a name="LaterList+length"></a>\n### laterList/Flood.length : <code>Number</code>\nNumber of nodes in the list.\n\n**Kind**: instance property of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n<a name="LaterList/Flood+addListener"></a>\n### laterList/Flood.addListener(onData, onEnd, initialValue)\nAdds a listener which processes values of this flood as soon as they\narrive.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| onData | <code>function</code> | A function applied to each node. |\n| onEnd | <code>function</code> | A function to execute on end. |\n| initialValue | <code>\\*</code> | An initial value. |\n\n<a name="LaterList+push"></a>\n### laterList/Flood.push(...values) ⇒ <code>Number</code>\nAdds a values to the list\'s tail. Pending listeners are revived and shifted.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Number</code> - The new length of the list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| ...values | <code>\\*</code> | The values to add to the end of the list. |\n\n<a name="LaterList+revive"></a>\n### laterList/Flood.revive(fn, err)\nExecutes a Listener.prototype function on each pending listener.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| fn | <code>function</code> | A Listener.prototype function. |\n| err | <code>Error</code> | Optional. An error to pass to pending listeners. |\n\n<a name="LaterList+end"></a>\n### laterList/Flood.end(err)\nIndicates that no more nodes will be added to the list. If an argument is\npresent it is interpreted as an error which will immediately end all\nlisteners. If no argument is present, listeners will end when they have\nprocessed all nodes of the list. Subsequent calls of push and end on this\nlist will throw.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| err | <code>error</code> | An optional error. |\n\n<a name="LaterList+link"></a>\n### laterList/Flood.link(onData) ⇒\nReturn a new LaterList instance whose nodes are the result of applying the\nsupplied onData function to each node of this list.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: LaterList A LaterList of the same subclass as this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| onData | <code>function</code> | A function to process nodes of this list                                     executed in the context of the listener. |\n\n<a name="LaterList+close"></a>\n### laterList/Flood.close()\nIndicates that no more listeners will be added to this list. The reference to\nthe head of the list is removed so that nodes processed by each listener may\nbe garbage colllected. Subsequent calls of [close](#LaterList+close),\n[atIndex](#LaterList+atIndex) and adding of listeners on this list will throw as\nthese methods require a reference to the list\'s head.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n<a name="LaterList+consume"></a>\n### laterList/Flood.consume(onData, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nReturns a promise that resolves with the final value of a listener.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The result of the computation of the listener.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| onData | <code>function</code> | A function to process nodes of this list                                    executed in the context of the listener. |\n| initialValue | <code>\\*</code> | An initial value set on the listener. |\n\n<a name="LaterList+value"></a>\n### laterList/Flood.value() ⇒ <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code>\nCollect the nodes of the list as an array.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code> - Resolves with the values of the list\'s nodes.  \n<a name="LaterList+atIndex"></a>\n### laterList/Flood.atIndex(index) ⇒ <code>\\*</code>\nLooks up the value of the node at the supplied index. Returns undefined if\nthe index is not a number or out of bounds.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>\\*</code> - The value of the node at that index.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| index | <code>Number</code> | An index of the list. |\n\n<a name="LaterList+when"></a>\n### laterList/Flood.when() ⇒ <code>Promise</code>\nResolves with undefined if the list ends without error, rejects if the list\nends with an error.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n<a name="LaterList+concat"></a>\n### laterList/Flood.concat(...lists) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a new list comprised of the list on which it is called joined with\nthe list-like(s) and/or value(s) provided as arguments.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list whose nodes have the concatenated values of the\n                    supplied arguments.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| ...lists | <code>Object.&lt;{forEach: function()}&gt;</code> | list-likes to concatenate                                                 to this list. |\n\n<a name="LaterList+every"></a>\n### laterList/Flood.every(predicate, thisArg) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nTests whether all nodes in the list pass the test implemented by the\nprovided function.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - true if the predicate is true for all nodes in\n                           the list, false otherwise.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+filter"></a>\n### laterList/Flood.filter(predicate, thisArg) ⇒ <code>[LaterList](#LaterList)</code>\nCreates a new LaterList with all nodes that pass the test implemented by\nthe provided function.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list with the filtered values of the original list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+find"></a>\n### laterList/Flood.find(predicate, thisArg) ⇒ <code>Promise.&lt;\\*&gt;</code>\nReturns a value in the list, if a node in the list satisfies the provided\ntesting function. Otherwise undefined is returned.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The value of the first node to satisfy the predicate.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+findIndex"></a>\n### laterList/Flood.findIndex(predicate, thisArg) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns an index in the list, if a node in the list satisfies the provided\ntesting function. Otherwise -1 is returned.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The first index of a node satisfying the\n                          predicate.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+forEach"></a>\n### laterList/Flood.forEach(lambda, thisArg) ⇒ <code>Promise.&lt;undefined&gt;</code>\nExecutes a provided function once per node.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;undefined&gt;</code> - Resolves when processing has ended.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the lambda. |\n\n<a name="LaterList+includes"></a>\n### laterList/Flood.includes(toMatch, fromIndex) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nDetermines whether a list includes a certain element, returning true or\nfalse as appropriate.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - Whether the value appears in the list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n| fromIndex | <code>Number</code> | Optional. The position in this list at which to                             begin searching for searchElement; defaults to                             0. |\n\n<a name="LaterList+indexOf"></a>\n### laterList/Flood.indexOf(toMatch) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns the first index at which a given value can be found in the list, or\n-1 if it is not present.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The first index of a node with the supplied value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n\n<a name="LaterList+join"></a>\n### laterList/Flood.join(separator) ⇒ <code>Promise.&lt;String&gt;</code>\nJoins all values of a list into a string.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| separator | <code>String</code> | Specifies a string to separate each value of                             the list. |\n\n<a name="LaterList+lastIndexOf"></a>\n### laterList/Flood.lastIndexOf(toMatch) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns the last index at which a given value can be found in the list, or\n-1 if it is not present.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The last index of a node with the supplied value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n\n<a name="LaterList+map"></a>\n### laterList/Flood.map(lambda, thisArg) ⇒ <code>[LaterList](#LaterList)</code>\nCreates a new list with the results of calling a provided function on every\nnode in this list.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the results of mapping the lambda over\n                    this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the lambda. |\n\n<a name="LaterList+reduce"></a>\n### laterList/Flood.reduce(lambda, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nApplies a function against an accumulator and each node of the list (from\nleft-to-right) has to reduce it to a single value.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The reduced value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| initialValue | <code>\\*</code> | Optional. Object to use as the                                           first argument to the first call                                           of the lambda. |\n\n<a name="LaterList+reduceRight"></a>\n### laterList/Flood.reduceRight(lambda, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nApplies a function against an accumulator and each node of the list (from\nright-to-left) has to reduce it to a single value. Note that this operation\ncan only commence when the list has ended and been reversed. As this is\ncomputationally expensive, finding other approaches is recommended.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The reduced value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| initialValue | <code>\\*</code> | Optional. Object to use as the                                           first argument to the first call                                           of the lambda. |\n\n<a name="LaterList+reverse"></a>\n### laterList/Flood.reverse() ⇒ <code>[LaterList](#LaterList)</code>\nReturns a reversed list. The first list node becomes the last and the last\nbecomes the first. Note that while this operation maintains a copy of each\nnode and can only complete when the list has ended. As this is\ncomputationally expensive, finding other approaches is recommended.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the values of this list reversed.  \n<a name="LaterList+slice"></a>\n### laterList/Flood.slice(begin, end) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a shallow copy of a portion of a list into a new list.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list with the sliced portion of this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| begin | <code>Number</code> | An index to begin at. |\n| end | <code>Number</code> | An index to end at. |\n\n<a name="LaterList+some"></a>\n### laterList/Flood.some(predicate, thisArg) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nTests whether some element in the list passes the test implemented by the\nprovided function.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - true if the predicate is true for some node in\n                           the list, false otherwise.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when executing                           predicate. |\n\n<a name="LaterList+sort"></a>\n### laterList/Flood.sort(compare) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a LaterList with the sorted nodes of this list. Note that this\noperation can only commence when the list has ended and requires all the\nvalues of the list collected in an array before they are sorted and copied\nto the resulting list. As this is computationally expensive, finding other\napproaches is recommended.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with sorted values from this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| compare | <code>function</code> | Optional. A function on which to sort. |\n\n<a name="LaterList+splice"></a>\n### laterList/Flood.splice(begin, deleteCount, ...additions) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a new list with some nodes in this list removed and/or some nodes\nadded.\n\n**Kind**: instance method of <code>[LaterList/Flood](#LaterList/Flood)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the modified values from this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| begin | <code>Number</code> | An index to begin at. |\n| deleteCount | <code>Number</code> | The number of elements to remove. |\n| ...additions | <code>\\*</code> | Values to add to the list. |\n\n<a name="LaterList/Relay"></a>\n## LaterList/Relay ⇐ <code>[LaterList](#LaterList)</code>\nA Relay is a LaterList for which order is preserved when listened\nto.\n\n**Kind**: global class  \n**Extends:** <code>[LaterList](#LaterList)</code>  \n\n* [LaterList/Relay](#LaterList/Relay) ⇐ <code>[LaterList](#LaterList)</code>\n  * [.length](#LaterList+length) : <code>Number</code>\n  * [.addListener(onData, onEnd, initialValue)](#LaterList/Relay+addListener)\n  * [.push(...values)](#LaterList+push) ⇒ <code>Number</code>\n  * [.revive(fn, err)](#LaterList+revive)\n  * [.end(err)](#LaterList+end)\n  * [.link(onData)](#LaterList+link) ⇒\n  * [.close()](#LaterList+close)\n  * [.consume(onData, initialValue)](#LaterList+consume) ⇒ <code>Promise.&lt;\\*&gt;</code>\n  * [.value()](#LaterList+value) ⇒ <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code>\n  * [.atIndex(index)](#LaterList+atIndex) ⇒ <code>\\*</code>\n  * [.when()](#LaterList+when) ⇒ <code>Promise</code>\n  * [.concat(...lists)](#LaterList+concat) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.every(predicate, thisArg)](#LaterList+every) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n  * [.filter(predicate, thisArg)](#LaterList+filter) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.find(predicate, thisArg)](#LaterList+find) ⇒ <code>Promise.&lt;\\*&gt;</code>\n  * [.findIndex(predicate, thisArg)](#LaterList+findIndex) ⇒ <code>Promise.&lt;Number&gt;</code>\n  * [.forEach(lambda, thisArg)](#LaterList+forEach) ⇒ <code>Promise.&lt;undefined&gt;</code>\n  * [.includes(toMatch, fromIndex)](#LaterList+includes) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n  * [.indexOf(toMatch)](#LaterList+indexOf) ⇒ <code>Promise.&lt;Number&gt;</code>\n  * [.join(separator)](#LaterList+join) ⇒ <code>Promise.&lt;String&gt;</code>\n  * [.lastIndexOf(toMatch)](#LaterList+lastIndexOf) ⇒ <code>Promise.&lt;Number&gt;</code>\n  * [.map(lambda, thisArg)](#LaterList+map) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.reduce(lambda, initialValue)](#LaterList+reduce) ⇒ <code>Promise.&lt;\\*&gt;</code>\n  * [.reduceRight(lambda, initialValue)](#LaterList+reduceRight) ⇒ <code>Promise.&lt;\\*&gt;</code>\n  * [.reverse()](#LaterList+reverse) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.slice(begin, end)](#LaterList+slice) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.some(predicate, thisArg)](#LaterList+some) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n  * [.sort(compare)](#LaterList+sort) ⇒ <code>[LaterList](#LaterList)</code>\n  * [.splice(begin, deleteCount, ...additions)](#LaterList+splice) ⇒ <code>[LaterList](#LaterList)</code>\n\n<a name="LaterList+length"></a>\n### laterList/Relay.length : <code>Number</code>\nNumber of nodes in the list.\n\n**Kind**: instance property of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n<a name="LaterList/Relay+addListener"></a>\n### laterList/Relay.addListener(onData, onEnd, initialValue)\nAdds a listener which processes values of this relay when all prior values\nhave been processed.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| onData | <code>function</code> | A function applied to each node. |\n| onEnd | <code>function</code> | A function to execute on end. |\n| initialValue | <code>\\*</code> | An initial value. |\n\n<a name="LaterList+push"></a>\n### laterList/Relay.push(...values) ⇒ <code>Number</code>\nAdds a values to the list\'s tail. Pending listeners are revived and shifted.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Number</code> - The new length of the list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| ...values | <code>\\*</code> | The values to add to the end of the list. |\n\n<a name="LaterList+revive"></a>\n### laterList/Relay.revive(fn, err)\nExecutes a Listener.prototype function on each pending listener.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| fn | <code>function</code> | A Listener.prototype function. |\n| err | <code>Error</code> | Optional. An error to pass to pending listeners. |\n\n<a name="LaterList+end"></a>\n### laterList/Relay.end(err)\nIndicates that no more nodes will be added to the list. If an argument is\npresent it is interpreted as an error which will immediately end all\nlisteners. If no argument is present, listeners will end when they have\nprocessed all nodes of the list. Subsequent calls of push and end on this\nlist will throw.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| err | <code>error</code> | An optional error. |\n\n<a name="LaterList+link"></a>\n### laterList/Relay.link(onData) ⇒\nReturn a new LaterList instance whose nodes are the result of applying the\nsupplied onData function to each node of this list.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: LaterList A LaterList of the same subclass as this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| onData | <code>function</code> | A function to process nodes of this list                                     executed in the context of the listener. |\n\n<a name="LaterList+close"></a>\n### laterList/Relay.close()\nIndicates that no more listeners will be added to this list. The reference to\nthe head of the list is removed so that nodes processed by each listener may\nbe garbage colllected. Subsequent calls of [close](#LaterList+close),\n[atIndex](#LaterList+atIndex) and adding of listeners on this list will throw as\nthese methods require a reference to the list\'s head.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n<a name="LaterList+consume"></a>\n### laterList/Relay.consume(onData, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nReturns a promise that resolves with the final value of a listener.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The result of the computation of the listener.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| onData | <code>function</code> | A function to process nodes of this list                                    executed in the context of the listener. |\n| initialValue | <code>\\*</code> | An initial value set on the listener. |\n\n<a name="LaterList+value"></a>\n### laterList/Relay.value() ⇒ <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code>\nCollect the nodes of the list as an array.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code> - Resolves with the values of the list\'s nodes.  \n<a name="LaterList+atIndex"></a>\n### laterList/Relay.atIndex(index) ⇒ <code>\\*</code>\nLooks up the value of the node at the supplied index. Returns undefined if\nthe index is not a number or out of bounds.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>\\*</code> - The value of the node at that index.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| index | <code>Number</code> | An index of the list. |\n\n<a name="LaterList+when"></a>\n### laterList/Relay.when() ⇒ <code>Promise</code>\nResolves with undefined if the list ends without error, rejects if the list\nends with an error.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n<a name="LaterList+concat"></a>\n### laterList/Relay.concat(...lists) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a new list comprised of the list on which it is called joined with\nthe list-like(s) and/or value(s) provided as arguments.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list whose nodes have the concatenated values of the\n                    supplied arguments.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| ...lists | <code>Object.&lt;{forEach: function()}&gt;</code> | list-likes to concatenate                                                 to this list. |\n\n<a name="LaterList+every"></a>\n### laterList/Relay.every(predicate, thisArg) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nTests whether all nodes in the list pass the test implemented by the\nprovided function.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - true if the predicate is true for all nodes in\n                           the list, false otherwise.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+filter"></a>\n### laterList/Relay.filter(predicate, thisArg) ⇒ <code>[LaterList](#LaterList)</code>\nCreates a new LaterList with all nodes that pass the test implemented by\nthe provided function.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list with the filtered values of the original list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+find"></a>\n### laterList/Relay.find(predicate, thisArg) ⇒ <code>Promise.&lt;\\*&gt;</code>\nReturns a value in the list, if a node in the list satisfies the provided\ntesting function. Otherwise undefined is returned.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The value of the first node to satisfy the predicate.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+findIndex"></a>\n### laterList/Relay.findIndex(predicate, thisArg) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns an index in the list, if a node in the list satisfies the provided\ntesting function. Otherwise -1 is returned.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The first index of a node satisfying the\n                          predicate.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+forEach"></a>\n### laterList/Relay.forEach(lambda, thisArg) ⇒ <code>Promise.&lt;undefined&gt;</code>\nExecutes a provided function once per node.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;undefined&gt;</code> - Resolves when processing has ended.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the lambda. |\n\n<a name="LaterList+includes"></a>\n### laterList/Relay.includes(toMatch, fromIndex) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nDetermines whether a list includes a certain element, returning true or\nfalse as appropriate.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - Whether the value appears in the list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n| fromIndex | <code>Number</code> | Optional. The position in this list at which to                             begin searching for searchElement; defaults to                             0. |\n\n<a name="LaterList+indexOf"></a>\n### laterList/Relay.indexOf(toMatch) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns the first index at which a given value can be found in the list, or\n-1 if it is not present.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The first index of a node with the supplied value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n\n<a name="LaterList+join"></a>\n### laterList/Relay.join(separator) ⇒ <code>Promise.&lt;String&gt;</code>\nJoins all values of a list into a string.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| separator | <code>String</code> | Specifies a string to separate each value of                             the list. |\n\n<a name="LaterList+lastIndexOf"></a>\n### laterList/Relay.lastIndexOf(toMatch) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns the last index at which a given value can be found in the list, or\n-1 if it is not present.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The last index of a node with the supplied value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n\n<a name="LaterList+map"></a>\n### laterList/Relay.map(lambda, thisArg) ⇒ <code>[LaterList](#LaterList)</code>\nCreates a new list with the results of calling a provided function on every\nnode in this list.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the results of mapping the lambda over\n                    this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the lambda. |\n\n<a name="LaterList+reduce"></a>\n### laterList/Relay.reduce(lambda, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nApplies a function against an accumulator and each node of the list (from\nleft-to-right) has to reduce it to a single value.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The reduced value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| initialValue | <code>\\*</code> | Optional. Object to use as the                                           first argument to the first call                                           of the lambda. |\n\n<a name="LaterList+reduceRight"></a>\n### laterList/Relay.reduceRight(lambda, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nApplies a function against an accumulator and each node of the list (from\nright-to-left) has to reduce it to a single value. Note that this operation\ncan only commence when the list has ended and been reversed. As this is\ncomputationally expensive, finding other approaches is recommended.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The reduced value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| initialValue | <code>\\*</code> | Optional. Object to use as the                                           first argument to the first call                                           of the lambda. |\n\n<a name="LaterList+reverse"></a>\n### laterList/Relay.reverse() ⇒ <code>[LaterList](#LaterList)</code>\nReturns a reversed list. The first list node becomes the last and the last\nbecomes the first. Note that while this operation maintains a copy of each\nnode and can only complete when the list has ended. As this is\ncomputationally expensive, finding other approaches is recommended.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the values of this list reversed.  \n<a name="LaterList+slice"></a>\n### laterList/Relay.slice(begin, end) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a shallow copy of a portion of a list into a new list.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list with the sliced portion of this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| begin | <code>Number</code> | An index to begin at. |\n| end | <code>Number</code> | An index to end at. |\n\n<a name="LaterList+some"></a>\n### laterList/Relay.some(predicate, thisArg) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nTests whether some element in the list passes the test implemented by the\nprovided function.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - true if the predicate is true for some node in\n                           the list, false otherwise.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when executing                           predicate. |\n\n<a name="LaterList+sort"></a>\n### laterList/Relay.sort(compare) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a LaterList with the sorted nodes of this list. Note that this\noperation can only commence when the list has ended and requires all the\nvalues of the list collected in an array before they are sorted and copied\nto the resulting list. As this is computationally expensive, finding other\napproaches is recommended.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with sorted values from this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| compare | <code>function</code> | Optional. A function on which to sort. |\n\n<a name="LaterList+splice"></a>\n### laterList/Relay.splice(begin, deleteCount, ...additions) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a new list with some nodes in this list removed and/or some nodes\nadded.\n\n**Kind**: instance method of <code>[LaterList/Relay](#LaterList/Relay)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the modified values from this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| begin | <code>Number</code> | An index to begin at. |\n| deleteCount | <code>Number</code> | The number of elements to remove. |\n| ...additions | <code>\\*</code> | Values to add to the list. |\n\n<a name="LaterList"></a>\n## LaterList\nA LaterList is a linked list which may be used to process values\nthat arrive or are processed asynchronously.\n\n**Kind**: global class  \n\n* [LaterList](#LaterList)\n  * _instance_\n    * [.length](#LaterList+length) : <code>Number</code>\n    * [.push(...values)](#LaterList+push) ⇒ <code>Number</code>\n    * [.revive(fn, err)](#LaterList+revive)\n    * [.end(err)](#LaterList+end)\n    * [.link(onData)](#LaterList+link) ⇒\n    * [.close()](#LaterList+close)\n    * [.consume(onData, initialValue)](#LaterList+consume) ⇒ <code>Promise.&lt;\\*&gt;</code>\n    * [.value()](#LaterList+value) ⇒ <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code>\n    * [.atIndex(index)](#LaterList+atIndex) ⇒ <code>\\*</code>\n    * [.when()](#LaterList+when) ⇒ <code>Promise</code>\n    * [.concat(...lists)](#LaterList+concat) ⇒ <code>[LaterList](#LaterList)</code>\n    * [.every(predicate, thisArg)](#LaterList+every) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n    * [.filter(predicate, thisArg)](#LaterList+filter) ⇒ <code>[LaterList](#LaterList)</code>\n    * [.find(predicate, thisArg)](#LaterList+find) ⇒ <code>Promise.&lt;\\*&gt;</code>\n    * [.findIndex(predicate, thisArg)](#LaterList+findIndex) ⇒ <code>Promise.&lt;Number&gt;</code>\n    * [.forEach(lambda, thisArg)](#LaterList+forEach) ⇒ <code>Promise.&lt;undefined&gt;</code>\n    * [.includes(toMatch, fromIndex)](#LaterList+includes) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n    * [.indexOf(toMatch)](#LaterList+indexOf) ⇒ <code>Promise.&lt;Number&gt;</code>\n    * [.join(separator)](#LaterList+join) ⇒ <code>Promise.&lt;String&gt;</code>\n    * [.lastIndexOf(toMatch)](#LaterList+lastIndexOf) ⇒ <code>Promise.&lt;Number&gt;</code>\n    * [.map(lambda, thisArg)](#LaterList+map) ⇒ <code>[LaterList](#LaterList)</code>\n    * [.reduce(lambda, initialValue)](#LaterList+reduce) ⇒ <code>Promise.&lt;\\*&gt;</code>\n    * [.reduceRight(lambda, initialValue)](#LaterList+reduceRight) ⇒ <code>Promise.&lt;\\*&gt;</code>\n    * [.reverse()](#LaterList+reverse) ⇒ <code>[LaterList](#LaterList)</code>\n    * [.slice(begin, end)](#LaterList+slice) ⇒ <code>[LaterList](#LaterList)</code>\n    * [.some(predicate, thisArg)](#LaterList+some) ⇒ <code>Promise.&lt;Boolean&gt;</code>\n    * [.sort(compare)](#LaterList+sort) ⇒ <code>[LaterList](#LaterList)</code>\n    * [.splice(begin, deleteCount, ...additions)](#LaterList+splice) ⇒ <code>[LaterList](#LaterList)</code>\n  * _static_\n    * [.from(listLike, mapFn, thisArg)](#LaterList.from) ⇒\n    * [.of(...values)](#LaterList.of) ⇒\n\n<a name="LaterList+length"></a>\n### laterList.length : <code>Number</code>\nNumber of nodes in the list.\n\n**Kind**: instance property of <code>[LaterList](#LaterList)</code>  \n<a name="LaterList+push"></a>\n### laterList.push(...values) ⇒ <code>Number</code>\nAdds a values to the list\'s tail. Pending listeners are revived and shifted.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Number</code> - The new length of the list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| ...values | <code>\\*</code> | The values to add to the end of the list. |\n\n<a name="LaterList+revive"></a>\n### laterList.revive(fn, err)\nExecutes a Listener.prototype function on each pending listener.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| fn | <code>function</code> | A Listener.prototype function. |\n| err | <code>Error</code> | Optional. An error to pass to pending listeners. |\n\n<a name="LaterList+end"></a>\n### laterList.end(err)\nIndicates that no more nodes will be added to the list. If an argument is\npresent it is interpreted as an error which will immediately end all\nlisteners. If no argument is present, listeners will end when they have\nprocessed all nodes of the list. Subsequent calls of push and end on this\nlist will throw.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| err | <code>error</code> | An optional error. |\n\n<a name="LaterList+link"></a>\n### laterList.link(onData) ⇒\nReturn a new LaterList instance whose nodes are the result of applying the\nsupplied onData function to each node of this list.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: LaterList A LaterList of the same subclass as this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| onData | <code>function</code> | A function to process nodes of this list                                     executed in the context of the listener. |\n\n<a name="LaterList+close"></a>\n### laterList.close()\nIndicates that no more listeners will be added to this list. The reference to\nthe head of the list is removed so that nodes processed by each listener may\nbe garbage colllected. Subsequent calls of [close](#LaterList+close),\n[atIndex](#LaterList+atIndex) and adding of listeners on this list will throw as\nthese methods require a reference to the list\'s head.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n<a name="LaterList+consume"></a>\n### laterList.consume(onData, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nReturns a promise that resolves with the final value of a listener.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The result of the computation of the listener.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| onData | <code>function</code> | A function to process nodes of this list                                    executed in the context of the listener. |\n| initialValue | <code>\\*</code> | An initial value set on the listener. |\n\n<a name="LaterList+value"></a>\n### laterList.value() ⇒ <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code>\nCollect the nodes of the list as an array.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;Array.&lt;\\*&gt;&gt;</code> - Resolves with the values of the list\'s nodes.  \n<a name="LaterList+atIndex"></a>\n### laterList.atIndex(index) ⇒ <code>\\*</code>\nLooks up the value of the node at the supplied index. Returns undefined if\nthe index is not a number or out of bounds.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>\\*</code> - The value of the node at that index.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| index | <code>Number</code> | An index of the list. |\n\n<a name="LaterList+when"></a>\n### laterList.when() ⇒ <code>Promise</code>\nResolves with undefined if the list ends without error, rejects if the list\nends with an error.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n<a name="LaterList+concat"></a>\n### laterList.concat(...lists) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a new list comprised of the list on which it is called joined with\nthe list-like(s) and/or value(s) provided as arguments.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list whose nodes have the concatenated values of the\n                    supplied arguments.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| ...lists | <code>Object.&lt;{forEach: function()}&gt;</code> | list-likes to concatenate                                                 to this list. |\n\n<a name="LaterList+every"></a>\n### laterList.every(predicate, thisArg) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nTests whether all nodes in the list pass the test implemented by the\nprovided function.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - true if the predicate is true for all nodes in\n                           the list, false otherwise.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+filter"></a>\n### laterList.filter(predicate, thisArg) ⇒ <code>[LaterList](#LaterList)</code>\nCreates a new LaterList with all nodes that pass the test implemented by\nthe provided function.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list with the filtered values of the original list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+find"></a>\n### laterList.find(predicate, thisArg) ⇒ <code>Promise.&lt;\\*&gt;</code>\nReturns a value in the list, if a node in the list satisfies the provided\ntesting function. Otherwise undefined is returned.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The value of the first node to satisfy the predicate.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+findIndex"></a>\n### laterList.findIndex(predicate, thisArg) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns an index in the list, if a node in the list satisfies the provided\ntesting function. Otherwise -1 is returned.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The first index of a node satisfying the\n                          predicate.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the predicate. |\n\n<a name="LaterList+forEach"></a>\n### laterList.forEach(lambda, thisArg) ⇒ <code>Promise.&lt;undefined&gt;</code>\nExecutes a provided function once per node.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;undefined&gt;</code> - Resolves when processing has ended.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the lambda. |\n\n<a name="LaterList+includes"></a>\n### laterList.includes(toMatch, fromIndex) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nDetermines whether a list includes a certain element, returning true or\nfalse as appropriate.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - Whether the value appears in the list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n| fromIndex | <code>Number</code> | Optional. The position in this list at which to                             begin searching for searchElement; defaults to                             0. |\n\n<a name="LaterList+indexOf"></a>\n### laterList.indexOf(toMatch) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns the first index at which a given value can be found in the list, or\n-1 if it is not present.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The first index of a node with the supplied value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n\n<a name="LaterList+join"></a>\n### laterList.join(separator) ⇒ <code>Promise.&lt;String&gt;</code>\nJoins all values of a list into a string.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| separator | <code>String</code> | Specifies a string to separate each value of                             the list. |\n\n<a name="LaterList+lastIndexOf"></a>\n### laterList.lastIndexOf(toMatch) ⇒ <code>Promise.&lt;Number&gt;</code>\nReturns the last index at which a given value can be found in the list, or\n-1 if it is not present.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;Number&gt;</code> - The last index of a node with the supplied value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| toMatch | <code>\\*</code> | A value to match. |\n\n<a name="LaterList+map"></a>\n### laterList.map(lambda, thisArg) ⇒ <code>[LaterList](#LaterList)</code>\nCreates a new list with the results of calling a provided function on every\nnode in this list.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the results of mapping the lambda over\n                    this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| thisArg | <code>Object</code> | Optional. Value to use as this when                                      executing the lambda. |\n\n<a name="LaterList+reduce"></a>\n### laterList.reduce(lambda, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nApplies a function against an accumulator and each node of the list (from\nleft-to-right) has to reduce it to a single value.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The reduced value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| initialValue | <code>\\*</code> | Optional. Object to use as the                                           first argument to the first call                                           of the lambda. |\n\n<a name="LaterList+reduceRight"></a>\n### laterList.reduceRight(lambda, initialValue) ⇒ <code>Promise.&lt;\\*&gt;</code>\nApplies a function against an accumulator and each node of the list (from\nright-to-left) has to reduce it to a single value. Note that this operation\ncan only commence when the list has ended and been reversed. As this is\ncomputationally expensive, finding other approaches is recommended.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;\\*&gt;</code> - The reduced value.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| lambda | <code>function</code> | Function to execute for each element |\n| initialValue | <code>\\*</code> | Optional. Object to use as the                                           first argument to the first call                                           of the lambda. |\n\n<a name="LaterList+reverse"></a>\n### laterList.reverse() ⇒ <code>[LaterList](#LaterList)</code>\nReturns a reversed list. The first list node becomes the last and the last\nbecomes the first. Note that while this operation maintains a copy of each\nnode and can only complete when the list has ended. As this is\ncomputationally expensive, finding other approaches is recommended.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the values of this list reversed.  \n<a name="LaterList+slice"></a>\n### laterList.slice(begin, end) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a shallow copy of a portion of a list into a new list.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A list with the sliced portion of this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| begin | <code>Number</code> | An index to begin at. |\n| end | <code>Number</code> | An index to end at. |\n\n<a name="LaterList+some"></a>\n### laterList.some(predicate, thisArg) ⇒ <code>Promise.&lt;Boolean&gt;</code>\nTests whether some element in the list passes the test implemented by the\nprovided function.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>Promise.&lt;Boolean&gt;</code> - true if the predicate is true for some node in\n                           the list, false otherwise.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| predicate | <code>function</code> | Function to test for each element. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when executing                           predicate. |\n\n<a name="LaterList+sort"></a>\n### laterList.sort(compare) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a LaterList with the sorted nodes of this list. Note that this\noperation can only commence when the list has ended and requires all the\nvalues of the list collected in an array before they are sorted and copied\nto the resulting list. As this is computationally expensive, finding other\napproaches is recommended.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with sorted values from this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| compare | <code>function</code> | Optional. A function on which to sort. |\n\n<a name="LaterList+splice"></a>\n### laterList.splice(begin, deleteCount, ...additions) ⇒ <code>[LaterList](#LaterList)</code>\nReturns a new list with some nodes in this list removed and/or some nodes\nadded.\n\n**Kind**: instance method of <code>[LaterList](#LaterList)</code>  \n**Returns**: <code>[LaterList](#LaterList)</code> - A new list with the modified values from this list.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| begin | <code>Number</code> | An index to begin at. |\n| deleteCount | <code>Number</code> | The number of elements to remove. |\n| ...additions | <code>\\*</code> | Values to add to the list. |\n\n<a name="LaterList.from"></a>\n### LaterList.from(listLike, mapFn, thisArg) ⇒\nCreates a new LaterList instance from an list-like object with a forEach\nmethod. The new list ends when the execution of forEach resolves.\n\n**Kind**: static method of <code>[LaterList](#LaterList)</code>  \n**Returns**: LaterList An instance of LaterList whose nodes have values equal to\n                    those of the supplied list-like.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| listLike | <code>Object.&lt;{forEach: function()}&gt;</code> | An object to create a list                                                 from. |\n| mapFn | <code>function</code> | Optional. Map function to call on every element of                            the list. |\n| thisArg | <code>Object</code> | Optional. Value to use as this when executing                             mapFn. |\n\n<a name="LaterList.of"></a>\n### LaterList.of(...values) ⇒\nCreates a new LaterList instance with a variable number of arguments.\n\n**Kind**: static method of <code>[LaterList](#LaterList)</code>  \n**Returns**: LaterList An instance of LaterList whose nodes have values equal to\n                    those of the supplied arguments.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| ...values | <code>\\*</code> | The values to add to a new list. |\n\n',
19 silly publish   readmeFilename: 'README.md',
19 silly publish   gitHead: 'dc23d67d87e081e829bc8cfd978e64279427cb57',
19 silly publish   _id: 'laterlist@1.0.0',
19 silly publish   _shasum: '7159ed3563cafa7b688aa222de351592d10ce4b9',
19 silly publish   _from: '.' }
20 silly mapToRegistry name laterlist
21 silly mapToRegistry using default registry
22 silly mapToRegistry registry https://registry.npmjs.org/
23 silly mapToRegistry uri https://registry.npmjs.org/laterlist
24 verbose publish registryBase https://registry.npmjs.org/
25 silly publish uploading /Users/willweiss/.npm/laterlist/1.0.0/package.tgz
26 verbose request uri https://registry.npmjs.org/laterlist
27 verbose request sending authorization for write operation
28 info attempt registry request try #1 at 18:15:00
29 verbose request using bearer token for auth
30 verbose request id 7ad20c020b108c8d
31 http request PUT https://registry.npmjs.org/laterlist
32 http 403 https://registry.npmjs.org/laterlist
33 verbose headers { 'content-type': 'application/json',
33 verbose headers   'cache-control': 'max-age=60',
33 verbose headers   'content-length': '95',
33 verbose headers   'accept-ranges': 'bytes',
33 verbose headers   date: 'Sun, 09 Aug 2015 22:15:01 GMT',
33 verbose headers   via: '1.1 varnish',
33 verbose headers   connection: 'keep-alive',
33 verbose headers   'x-served-by': 'cache-atl6221-ATL',
33 verbose headers   'x-cache': 'MISS',
33 verbose headers   'x-cache-hits': '0',
33 verbose headers   'x-timer': 'S1439158501.436891,VS0,VE540' }
34 verbose request invalidating /Users/willweiss/.npm/registry.npmjs.org/laterlist on PUT
35 error publish Failed PUT 403
36 verbose stack Error: "You cannot publish over the previously published version 1.0.0." : laterlist
36 verbose stack     at CachingRegistryClient.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/npm-registry-client/lib/request.js:254:14)
36 verbose stack     at Request._callback (/usr/local/lib/node_modules/npm/node_modules/npm-registry-client/lib/request.js:178:14)
36 verbose stack     at Request.self.callback (/usr/local/lib/node_modules/npm/node_modules/request/request.js:373:22)
36 verbose stack     at Request.emit (events.js:98:17)
36 verbose stack     at Request.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/request/request.js:1318:14)
36 verbose stack     at Request.emit (events.js:117:20)
36 verbose stack     at IncomingMessage.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/request/request.js:1266:12)
36 verbose stack     at IncomingMessage.emit (events.js:117:20)
36 verbose stack     at _stream_readable.js:943:16
36 verbose stack     at process._tickCallback (node.js:419:13)
37 verbose statusCode 403
38 verbose pkgid laterlist
39 verbose cwd /Users/willweiss/dev/LaterList
40 error Darwin 14.4.0
41 error argv "node" "/usr/local/bin/npm" "publish"
42 error node v0.10.33
43 error npm  v2.4.1
44 error code E403
45 error "You cannot publish over the previously published version 1.0.0." : laterlist
46 error If you need help, you may report this error at:
46 error     <http://github.com/npm/npm/issues>
47 verbose exit [ 1, true ]
